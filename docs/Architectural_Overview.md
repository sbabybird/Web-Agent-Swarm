# 架构概览

本文档概述了 Web Agent Swarm 项目的架构。该项目利用大语言模型（LLM）来理解用户目标，并为各种工具生成相应的命令。

## 核心理念
本架构围绕着“关注点分离”的核心原则进行设计：

1.  **后端 (LLM 代理)**：一个轻量级的 Node.js 服务器，其唯一职责是作为前端与本地 LLM 服务之间的代理。它不包含任何特定于应用程序的业务逻辑。
2.  **前端 (UI 与工具实现)**：一个基于 React 的单页面应用，负责处理所有用户交互，并且（至关重要地）包含了所有工具（例如 Canvas 工具）的完整实现。
3.  **多智能体协作协议 (MCP)**：一个基于 JSON 的协议，用于定义 LLM 与工具之间通信所使用的命令和事件的结构。

## 高层流程
1.  **用户目标**：用户在前端界面输入一个高层级的目标（例如，“画一座房子”）。
2.  **管理者智能体 (LLM)**：前端将用户目标发送给在 LLM 上运行的“管理者”智能体（通过后端代理）。管理者的任务是分析目标，并确定哪个专业工具最适合该任务（例如，`drawing`）。
3.  **专家智能体 (LLM)**：然后，前端将目标发送给一个特定的“专家”智能体（例如，`绘画专家`）。该专家的提示词经过专门设计，旨在引导 LLM 将用户目标转换为一系列针对目标工具的 MCP 命令。
4.  **MCP 命令生成**：LLM 生成一个命令的 JSON 数组（例如，`[{"action": "clear_rect", ...}, {"action": "fill_rect", ...}]`）。
5.  **前端工具执行**：前端接收到这个 JSON 数组。一个在浏览器内运行的 `MCPBroker` 将这些命令转发给相关的 `CanvasMCPServer` 实例，该实例也完全运行在前端。
6.  **直接 DOM 操作**：`CanvasMCPServer` 解析这些命令，并通过直接调用浏览器原生的 Canvas 2D API 来执行它们，从而即时更新页面上的 `<canvas>` 元素。

## 此架构的主要优势
*   **高效性**：通过将工具的实现和执行完全保留在前端，我们避免了因 UI 更新而产生的缓慢且不必要的网络往返。无需通过 WebSocket 序列化和发送整个画布图像。
*   **简洁性**：后端极其简单且无状态，易于维护和扩展。前端包含了所有的 UI 和工具逻辑，实现了清晰的分离。
*   **可扩展性**：添加新工具非常直接。只需创建一个新的`专家`提示词、一个新的前端 `MCPServer`，并将其添加到 `App.tsx` 的逻辑中即可。无需更改后端。
*   **强大性**：此架构充分利用了浏览器环境的强大能力，以提供丰富的交互式体验，同时将复杂的推理任务卸载给了 LLM。
