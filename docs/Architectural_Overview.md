# 架构概览

本文档概述了 Web Agent Swarm 项目的架构。该项目利用大语言模型（LLM）来理解用户目标，并为各种工具生成相应的命令。

## 核心理念
本架构围绕着“关注点分离”的核心原则进行设计：

1.  **后端 (LLM 代理)**：一个轻量级的 Node.js 服务器，其唯一职责是作为前端与本地 LLM 服务之间的代理。它不包含任何特定于应用程序的业务逻辑。
2.  **前端 (UI 与工具实现)**：一个基于 React 的单页面应用，负责处理所有用户交互，并且（至关重要地）包含了所有工具（例如 Canvas 2D 和 Three.js 3D 场景）的完整实现。
3.  **多智能体协作协议 (MCP)**：一套基于 JSON 的协议，用于定义 LLM 与前端工具之间通信所使用的命令和事件的结构。每种能力（如 2D 绘图、3D 场景）都有其独立的 MCP Schema。

## 高层流程
1.  **用户目标**：用户在前端界面输入一个高层级的目标（例如，“画一座房子”或“创建一个有红色立方体的 3D 场景”）。
2.  **管理者智能体 (LLM)**：前端将用户目标发送给在 LLM 上运行的“管理者”智能体。管理者的任务是分析目标，并确定哪个专家最适合该任务（例如，`canvas_expert` 或 `scene_expert`）。
3.  **专家智能体 (LLM)**：然后，前端将目标发送给一个特定的“专家”智能体（例如，`绘画专家`或`场景专家`）。该专家的提示词（包含了对应能力的 MCP Schema 和指导范例）经过专门设计，旨在引导 LLM 将用户目标转换为一系列针对目标工具的 MCP 命令。
4.  **MCP 命令生成**：LLM 生成一个命令的 JSON 数组（例如，`[{"action": "clear_rect", ...}]` 或 `[{"action": "create_mesh", ...}]`）。
5.  **前端工具执行**：前端的 `pubsub` 系统将这些命令转发给相关的“MCP 服务器”实例（`CanvasMCPServer` 或 `SceneMCPServer`），这些实例也完全运行在前端。
6.  **直接 DOM/WebGL 操作**：“MCP 服务器”解析这些命令，并通过直接调用浏览器原生的 API（Canvas 2D 或 WebGL/Three.js）来执行它们，从而即时更新页面上的相应区域。

## 此架构的主要优势
*   **高效性**：通过将工具的实现和执行完全保留在前端，我们避免了因 UI 更新而产生的缓慢且不必要的网络往返。
*   **简洁性**：后端极其简单且无状态，易于维护和扩展。前端包含了所有的 UI 和工具逻辑，实现了清晰的分离。
*   **可扩展性**：添加新能力（例如，一个音频合成工具）非常直接。只需：
    1.  定义一个新的 MCP Schema。
    2.  创建一个新的“专家”智能体和相应的提示文件。
    3.  创建一个新的前端“MCP 服务器”来实现协议。
    4.  在 `App.tsx` 中注册新的智能体。
    5.  更新 `ManagerAgent` 的提示，让它知道新专家的存在。
*   **强大性**：此架构充分利用了浏览器环境的强大能力，以提供丰富的交互式体验，同时将复杂的推理任务卸载给了 LLM。